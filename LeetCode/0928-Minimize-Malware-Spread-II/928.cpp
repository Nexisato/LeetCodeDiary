#include <cstring>
#include <iostream>
#include <numeric>
#include <vector>
#include <unordered_set>
using namespace std;

class UnionFind {
private:
    vector<int> parent;
    vector<int> rank;
    int n;
    int count;

public:
    UnionFind(int _n)
        : n(_n), parent(vector<int>(_n)), rank(vector<int>(_n, 1)), count(_n) {
        iota(parent.begin(), parent.end(), 0);
    }
    int find(int x) {
        while (x != parent[x]) {
            int px = parent[x];
            parent[x] = parent[px];
            x = parent[x];
        }
        return x;
    }
    void merge(int x, int y) {
        int rootX = find(x), rootY = find(y);
        if (rootX == rootY) return;
        if (rank[rootX] <= rank[rootY]) {
            swap(rootX, rootY);
        }
        parent[rootY] = rootX;
        rank[rootX] += rank[rootY];
        --count;
    }
    bool isConnected(int x, int y) { return find(x) == find(y); }
    int getSize(int x) { return rank[x]; }
};

class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        const int n = graph.size();
        UnionFind uf(n);
        // 过滤掉 initial 中的节点
        vector<bool> isInfected(n, false);
        for (auto&& x : initial) isInfected[x] = true;
        for (int i = 0; i < n; ++i) {
            if (!isInfected[i]) {
                for (int j = i + 1; j < n; ++j) {
                    if (graph[i][j] && !isInfected[j]) {
                        uf.merge(i, j);
                    }
                }
            }
        }
        vector<int> count(n, 0);
        unordered_set<int> g[n];
        for (auto&& i : initial) {
            for (int j = 0; j < n; ++j) {
                if (graph[i][j] && !isInfected[j]) {
                    g[i].insert(uf.find(j));
                }
            }
            for (auto&& root : g[i])
                ++count[root];
        }
        int res = n, maxCnt = 0;
        for (auto&& i : initial) {
            int t = 0;
            for (auto&& root : g[i]) 
                if (count[root] == 1)
                    t += uf.getSize(root);
            if (t > maxCnt || (t == maxCnt && i < res)) {
                res = i;
                maxCnt = t;

            }
        }
        return res;
    }
};
int main() { return 0; }