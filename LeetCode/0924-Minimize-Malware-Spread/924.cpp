#include <vector>
#include <numeric> 
#include <algorithm>
#include <unordered_set>
using namespace std;

class UnionFind {
private:
    vector<int> parent;
    vector<int> rank;
    int count;
    int n;
public:
    UnionFind(int _n): 
        parent(vector<int>(_n)), 
        rank(vector<int>(_n, 1)), 
        count(_n), 
        n(_n) {
        iota(parent.begin(), parent.end(), 0);
    }
    int find(int x) {
        return x == parent[x] ? x : (parent[x] = find(parent[x]));
    }
    void merge(int x, int y) {
        int rootx = find(x), rooty = find(y);
        if (rootx != rooty) {
            if (rank[rootx] <= rank[rooty])
                swap(rootx, rooty);
            parent[rooty] = rootx;
            rank[rootx] += rank[rooty];
            --count;
        }
    }
    bool isConnected(int x, int y) {
        return find(x) == find(y);
    }
    int getSize(int x) {
        return rank[x];
    }

};
// 关于 count[x] == 1
// 该节点移除后，其他节点不会被感染，即便该节点后续被感染仍然不会影响到其他节点

class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        const int n = graph.size();
        UnionFind uf(n);
        unordered_set<int> initial_set(initial.begin(), initial.end());
        for (int i = 0; i < n; ++i) {
            for (int j = i + 1; j < n; ++j) {
                if (graph[i][j] == 1)
                    uf.merge(i, j);
            }
        }
        vector<int> count(n, 0);
        for (int i = 0; i < n; ++i) {
            ++count[uf.find(i)];
        }
        int res = n;
        int maxCnt = 0;
        for (int x : initial) {
            int root = uf.find(x);
            if (count[root] == 1) {
                int size = uf.getSize(root);
                if (size > maxCnt || (size == maxCnt && x < res)) {
                    res = x;
                    maxCnt = size;
                }
            }
        }
        return res == n ? *min_element(initial.begin(), initial.end()) : res;
    }
};
int main() {


    return 0;
}